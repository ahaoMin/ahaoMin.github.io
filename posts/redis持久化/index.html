<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。
Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。
持久化的几种方式 Redis 持久化拥有以下三种方式：
快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘； 文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中； 混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。 因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。
Redis持久化&amp;ndash;RDB RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。
持久化触发 RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。
手动触发 手动触发持久化的操作有两个： save 和 bgsave ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。
save 命令 在客户端中执行 save 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。
save 命令使用如下：从图片可以看出，当执行完 save 命令之后，持久化文件 dump.'><title>Redis持久化</title>

<link rel='canonical' href='https://ahao.ink/posts/redis%E6%8C%81%E4%B9%85%E5%8C%96/'>

<link rel="stylesheet" href="/scss/style.min.baba905ab2d1209de74a1930c487a8a663c37860af6aa1c26588d298bf620306.css"><meta property='og:title' content='Redis持久化'>
<meta property='og:description' content='Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。
Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。
持久化的几种方式 Redis 持久化拥有以下三种方式：
快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘； 文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中； 混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。 因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。
Redis持久化&amp;ndash;RDB RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。
持久化触发 RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。
手动触发 手动触发持久化的操作有两个： save 和 bgsave ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。
save 命令 在客户端中执行 save 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。
save 命令使用如下：从图片可以看出，当执行完 save 命令之后，持久化文件 dump.'>
<meta property='og:url' content='https://ahao.ink/posts/redis%E6%8C%81%E4%B9%85%E5%8C%96/'>
<meta property='og:site_name' content='ahao&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2021-09-26T13:36:41&#43;00:00'/><meta property='article:modified_time' content='2022-06-07T01:16:52&#43;00:00'/><meta property='og:image' content='https://ahao.ink/26.jpg' />
<meta name="twitter:title" content="Redis持久化">
<meta name="twitter:description" content="Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。
Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。
持久化的几种方式 Redis 持久化拥有以下三种方式：
快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘； 文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中； 混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。 因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。
Redis持久化&amp;ndash;RDB RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。
持久化触发 RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。
手动触发 手动触发持久化的操作有两个： save 和 bgsave ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。
save 命令 在客户端中执行 save 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。
save 命令使用如下：从图片可以看出，当执行完 save 命令之后，持久化文件 dump."><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://ahao.ink/26.jpg' />
    <link rel="shortcut icon" href="img/avatar_hua8acc2063f8134c9d13980a8a63800c2_11114_300x0_resize_box_3.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hua8acc2063f8134c9d13980a8a63800c2_11114_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🐷</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">ahao&#39;s Blog</a></h1>
            <h2 class="site-description">道阻且长，行则将至</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/'
                        target="_blank"
                        title="GitHub"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页 / Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档 / Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索 / Search</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于 / About</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/posts/redis%E6%8C%81%E4%B9%85%E5%8C%96/">
                
                    <img src="/26.jpg" loading="lazy" alt="Featured image of post Redis持久化" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/redis/" >
                Redis
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/redis%E6%8C%81%E4%B9%85%E5%8C%96/">Redis持久化</a>
        </h2>
    
        
    </div>

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2021年9月26日</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 7 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>
</header>

    <section class="article-content">
    
    
    <blockquote>
<p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/13/ufiDXC4ahNzKklE.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p>
<h1 id="持久化的几种方式">持久化的几种方式</h1>
<p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li>
</ul>
<p>因为每种持久化方案，都有特定的使用场景，让我们先从 RDB 持久化说起吧。</p>
<h1 id="redis持久化--rdb">Redis持久化&ndash;RDB</h1>
<p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p>
<h2 id="持久化触发">持久化触发</h2>
<p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p>
<h3 id="手动触发">手动触发</h3>
<p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p>
<h4 id="save-命令">save 命令</h4>
<p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用</strong>。</p>
<p><code>save</code> 命令使用如下：<img src="https://s2.loli.net/2021/12/13/sSyYdZjqoxbFa9I.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
>从图片可以看出，当执行完 <code>save</code> 命令之后，持久化文件 <code>dump.rdb</code> 的修改时间就变了，这就表示 <code>save</code> 成功的触发了 RDB 持久化。 <code>save</code> 命令执行流程，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/Zu17OH6QVMKaoIx.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h4 id="bgsave-命令">bgsave 命令</h4>
<p>bgsave（background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 fork() 一个子进程来执行持久化，整个过程中只有在 fork() 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。 <code>bgsave</code> 命令使用，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/qIsaFWgD1AoEVcp.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p><code>bgsave</code> 执行流程，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/mA4JU8edhRCOgw7.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h3 id="自动触发">自动触发</h3>
<p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p>
<h4 id="save-m-n">save m n</h4>
<p><code>save m n</code> 是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。 参数 m 和 n 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 save m n 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 save m n 命令：</p>
<ul>
<li>save 60 10</li>
<li>save 600 1</li>
</ul>
<p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p>
<h4 id="flushall">flushall</h4>
<p><code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。 执行结果如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/YDK4vj25S3mRCqd.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h3 id="主从同步触发">主从同步触发</h3>
<p>在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p>
<h2 id="配置说明">配置说明</h2>
<p>合理的设置 RDB 的配置，可以保障 Redis 高效且稳定的运行，下面一起来看 RDB 的配置项都有哪些？</p>
<p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># RDB 保存的条件
</span></span><span class="line"><span class="cl">save 900 1
</span></span><span class="line"><span class="cl">save 300 10
</span></span><span class="line"><span class="cl">save 60 10000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。
</span></span><span class="line"><span class="cl">stop-writes-on-bgsave-error yes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># RDB 文件压缩
</span></span><span class="line"><span class="cl">rdbcompression yes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。
</span></span><span class="line"><span class="cl">rdbchecksum yes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># RDB 文件名
</span></span><span class="line"><span class="cl">dbfilename dump.rdb
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># RDB 文件目录
</span></span><span class="line"><span class="cl">dir ./
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中比较重要的参数如下列表： <strong>① save 参数</strong> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p>
<ul>
<li>save 900 1：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li>
<li>save 300 10：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li>
<li>save 60 10000：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li>
</ul>
<p><strong>② rdbcompression 参数</strong> 它的默认值是 <code>yes</code> 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。 <strong>③ rdbchecksum 参数</strong> 它的默认值为 <code>yes</code> 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p>
<h2 id="配置查询">配置查询</h2>
<p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code> ，执行效果如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/AvDxyGWZjgbYPCi.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code> ，执行效果如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/tboEm6qycvLUfAl.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h2 id="配置设置">配置设置</h2>
<p>设置 RDB 的配置，可以通过以下两种方式：</p>
<ul>
<li>手动修改 Redis 配置文件；</li>
<li>使用命令行设置，例如，使用 <code>config set dir &quot;/usr/data&quot;</code> 就是用于修改 RDB 的存储目录。</li>
</ul>
<p><strong>注意</strong>：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p>
<blockquote>
<p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p>
</blockquote>
<h2 id="rdb-文件恢复">RDB 文件恢复</h2>
<p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。 如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。 <strong>验证 RDB 文件是否被加载</strong> Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/xgKkor47MyWFVdq.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
>从日志上可以看出， Redis 服务在启动时已经正常加载了 RDB 文件。</p>
<blockquote>
<p>小贴士：Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
</blockquote>
<h2 id="rdb-优缺点">RDB 优缺点</h2>
<h3 id="rdb-优点">RDB 优点</h3>
<ul>
<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>
<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>
<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li>
<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>
</ul>
<h3 id="rdb-缺点">RDB 缺点</h3>
<ul>
<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li>
<li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>
</ul>
<h2 id="禁用持久化">禁用持久化</h2>
<p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save &quot;&quot;</code> 命令即可禁用 Redis 的持久化，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/mRnuNCIKEVb9kso.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h2 id="小结">小结</h2>
<p>通过本文我们可以得知，RDB 持久化分为手动触发和自动触发两种方式，它的优点是存储文件小，Redis 启动 时恢复数据比较快，缺点是有丢失数据的风险。RDB 文件的恢复也很简单，只需要把 RDB 文件放到 Redis 的根目录，在 Redis 启动时就会自动加载并恢复数据。</p>
<h1 id="redis持久化--aof">Redis持久化&ndash;AOF</h1>
<p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p>
<p>可能会操作 Redis 服务意外终止的条件：</p>
<ul>
<li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li>
<li>安装 Redis 的机器出现电源故障，例如突然断电；</li>
<li>使用 <code>kill -9 Redis_PID</code> 等。</li>
</ul>
<p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p>
<h2 id="简介">简介</h2>
<p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p>
<h2 id="持久化查询和设置">持久化查询和设置</h2>
<h3 id="查询-aof-启动状态">查询 AOF 启动状态</h3>
<p>使用 <code>config get appendonly</code> 命令，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/lisbUCv97jf6DVG.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p>
<h3 id="开启-aof-持久化">开启 AOF 持久化</h3>
<p>Redis 默认是关闭 AOF 持久化的，想要开启 AOF 持久化，有以下两种方式：</p>
<ul>
<li>通过命令行的方式；</li>
<li>通过修改配置文件的方式（redis.conf）。</li>
</ul>
<p>下面分别来看以上两种方式的实现。</p>
<h4 id="命令行启动-aof">命令行启动 AOF</h4>
<p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/gv42tnQEfeAKLhF.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p><strong>命令行启动 AOF 的优缺点</strong>：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p>
<h4 id="配置文件启动-aof">配置文件启动 AOF</h4>
<p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/Sk2ItMY5AJ9deh3.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<p>只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 <code>appendonly no</code> 表示关闭 AOF 持久化。 <strong>配置文件启动 AOF 的优缺点</strong>：修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效。</p>
<h2 id="触发持久化">触发持久化</h2>
<p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p>
<h3 id="自动触发-1">自动触发</h3>
<p>有两种情况可以自动触发 AOF 持久化，分为是：<strong>满足 AOF 设置的策略触发</strong>和**满足 AOF 重写触发。**其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。 AOF 持久化策略，分为以下三种：</p>
<ul>
<li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li>
<li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li>
<li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li>
</ul>
<p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 开启每秒写入一次的持久化策略
</span></span><span class="line"><span class="cl">appendfsync everysec
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p>
</blockquote>
<p>触发自动持久化的两种情况，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/VKqGQcexHNJiMBh.png"
	
	
	
	loading="lazy"
	
		alt="image.png"
	
	
></p>
<h3 id="手动触发-1">手动触发</h3>
<p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/fqz6kOD5SLlbyvh.png"
	
	
	
	loading="lazy"
	
		alt="5.png"
	
	
>可以看出执行完 <code>bgrewriteaof</code> 命令之后，AOF 持久化就会被触发。</p>
<h2 id="aof-文件重写">AOF 文件重写</h2>
<p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p>
<h3 id="什么是-aof-重写">什么是 AOF 重写？</h3>
<p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p>
<h3 id="aof-重写实现">AOF 重写实现</h3>
<p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p>
<ul>
<li>auto-aof-rewrite-min-size：允许 AOF 重写的最小文件容量，默认是 64mb 。</li>
<li>auto-aof-rewrite-percentage：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li>
</ul>
<p>查询 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 的值，可使用 <code>config get xxx</code> 命令，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/rgkG3EoSVAPLvBm.png"
	
	
	
	loading="lazy"
	
		alt="6.png"
	
	
></p>
<blockquote>
<p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p>
</blockquote>
<p><strong>注意</strong>：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p>
<h3 id="aof-重写流程">AOF 重写流程</h3>
<p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p>
<h2 id="配置说明-1">配置说明</h2>
<p>合理的设置 AOF 的配置，可以保障 Redis 高效且稳定的运行，以下是 AOF 的全部配置信息和说明。</p>
<p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 <code>redis.conf</code> 文件中，配置参数和说明如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 是否开启 AOF，yes 为开启，默认是关闭
</span></span><span class="line"><span class="cl">appendonly no
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># AOF 默认文件名
</span></span><span class="line"><span class="cl">appendfilename &#34;appendonly.aof&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># AOF 持久化策略配置
</span></span><span class="line"><span class="cl"># appendfsync always
</span></span><span class="line"><span class="cl">appendfsync everysec
</span></span><span class="line"><span class="cl"># appendfsync no
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。
</span></span><span class="line"><span class="cl">auto-aof-rewrite-percentage 100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 允许 AOF 重写的最小文件容量
</span></span><span class="line"><span class="cl">auto-aof-rewrite-min-size 64mb
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。
</span></span><span class="line"><span class="cl"># 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。
</span></span><span class="line"><span class="cl">aof-load-truncated yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中比较重要的是 appendfsync 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p>
<h2 id="数据恢复">数据恢复</h2>
<h3 id="正常数据恢复">正常数据恢复</h3>
<p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/KzmOItHseNYlur8.png"
	
	
	
	loading="lazy"
	
		alt="7.png"
	
	
>其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p>
<blockquote>
<p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p>
</blockquote>
<p><strong>持久化文件加载规则</strong></p>
<ul>
<li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li>
<li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li>
<li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li>
</ul>
<p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/hj3UL1aKWNMciPo.png"
	
	
	
	loading="lazy"
	
		alt="8.png"
	
	
></p>
<h3 id="简单异常数据恢复">简单异常数据恢复</h3>
<p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p>
<p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 <code>aof-load-truncated</code> 等于 <code>yes</code> 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">* Reading RDB preamble from AOF file...
</span></span><span class="line"><span class="cl">* Reading the remaining AOF tail...
</span></span><span class="line"><span class="cl"># !!! Warning: short read while loading the AOF file !!!
</span></span><span class="line"><span class="cl"># !!! Truncating the AOF at offset 439 !!!
</span></span><span class="line"><span class="cl"># AOF loaded anyway because aof-load-truncated is enabled
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="复杂异常数据恢复">复杂异常数据恢复</h3>
<p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">* Reading the remaining AOF tail...
</span></span><span class="line"><span class="cl"># Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>出现此类问题的解决方案如下：</p>
<ol>
<li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 <code>redis-check-aof</code> 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li>
<li>如果无法手动修复，我们可以使用 <code>redis-check-aof --fix</code> 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li>
</ol>
<h2 id="优缺点">优缺点</h2>
<h3 id="aof-优点">AOF 优点</h3>
<ul>
<li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li>
<li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li>
<li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li>
</ul>
<h3 id="aof-缺点">AOF 缺点</h3>
<ul>
<li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li>
<li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li>
</ul>
<h2 id="小结-1">小结</h2>
<p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： <code>redis-check-aof --fix</code> ，为使用 AOF 提供了很好的保障。</p>
<h1 id="redis持久化--混合持久化">Redis持久化&ndash;混合持久化</h1>
<p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p>
<p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p>混合持久化的数据存储结构如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/3cotY1HUeVmBTz9.png"
	
	
	
	loading="lazy"
	
		alt="1.png"
	
	
></p>
<h2 id="开启混合持久化">开启混合持久化</h2>
<p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令，执行结果如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/JiAyCwT72amsGZW.png"
	
	
	
	loading="lazy"
	
		alt="2.png"
	
	
></p>
<p>其中 yes 表示已经开启混合持久化，no 表示关闭，Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p>
<ul>
<li>通过命令行开启</li>
<li>通过修改 Redis 配置文件开启</li>
</ul>
<h3 id="通过命令行开启">通过命令行开启</h3>
<p>使用命令 <code>config set aof-use-rdb-preamble yes</code> 执行结果如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/35XuvjFPskqHK1N.png"
	
	
	
	loading="lazy"
	
		alt="3.png"
	
	
></p>
<blockquote>
<p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p>
</blockquote>
<h3 id="通过修改-redis-配置文件开启">通过修改 Redis 配置文件开启</h3>
<p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code> 如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/iRjq3npEXoUJ1Ms.png"
	
	
	
	loading="lazy"
	
		alt="4.png"
	
	
></p>
<h2 id="实例运行">实例运行</h2>
<p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 appendonly.aof 文件的持久化日志，如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/3Iw8H2O9nG6heSd.png"
	
	
	
	loading="lazy"
	
		alt="5.png"
	
	
>可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 appendonly.aof 的文件内容如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/6vgK4qOG9RTrsQM.png"
	
	
	
	loading="lazy"
	
		alt="6.png"
	
	
>可以看出 appendonly.aof 文件存储的内容是 <code>REDIS</code> 开头的 RDB 格式的内容，并非为 AOF 格式的日志。</p>
<h2 id="数据恢复和源码解析">数据恢复和源码解析</h2>
<p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/mf4KbVkguNq1dSe.png"
	
	
	
	loading="lazy"
	
		alt="7.png"
	
	
>可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p>
<h3 id="混合持久化的加载流程">混合持久化的加载流程</h3>
<p>混合持久化的加载流程如下：</p>
<ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p>AOF 加载流程图如下图所示：</p>
<p><img src="https://s2.loli.net/2021/12/13/2TSVJctWKh1d3ak.png"
	
	
	
	loading="lazy"
	
		alt="8.png"
	
	
></p>
<h3 id="源码解析">源码解析</h3>
<p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 src/aof.c 中，核心代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">sig</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="cm">/* &#34;REDIS&#34; */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">fread</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span><span class="s">&#34;REDIS&#34;</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// AOF 文件开头非 RDB 格式，非混合持久化文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">goto</span> <span class="n">readerr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* RDB preamble. Pass loading the RDB functions. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">rio</span> <span class="n">rdb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;Reading RDB preamble from AOF file...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">goto</span> <span class="n">readerr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rioInitWithFile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdb</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">rdbLoadRio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdb</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">C_OK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_WARNING</span><span class="p">,</span><span class="s">&#34;Error reading the RDB preamble of the AOF file, AOF loading aborted&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">readerr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;Reading the remaining AOF tail...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 加载 AOF 格式的数据
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p>
<blockquote>
<p>小贴士：AOF 格式的开头是 *，而 RDB 格式的开头是 REDIS。</p>
</blockquote>
<h2 id="优缺点-1">优缺点</h2>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h2 id="持久化最佳实践">持久化最佳实践</h2>
<p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p>
<h3 id="控制持久化开关">控制持久化开关</h3>
<p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p>
<ul>
<li>关闭 RDB 持久化，使用命令： <code>config set save &quot;&quot;</code></li>
<li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li>
</ul>
<h3 id="主从部署">主从部署</h3>
<p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p>
<h3 id="使用混合持久化">使用混合持久化</h3>
<p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p>
<h3 id="使用配置更高的机器">使用配置更高的机器</h3>
<p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 2022年6月7日 01:16 UTC
        </span>
    </section></footer>


    
</article>

    

    

<aside class="related-contents--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-contents">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/posts/redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E5%BC%8F/">
        
        
            <div class="article-image">
                
                    <img src="/24.jpg" loading="lazy" data-key="" data-hash="/24.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Redis 高可用方式</h2>
        </div>
    </a>
</article>
            
                
<article class="has-image">
    <a href="/posts/redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
        
        
            <div class="article-image">
                
                    <img src="/23.jpg" loading="lazy" data-key="" data-hash="/23.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Redis常用数据类型</h2>
        </div>
    </a>
</article>
            
                
<article class="has-image">
    <a href="/posts/redis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/">
        
        
            <div class="article-image">
                
                    <img src="/27.jpg" loading="lazy" data-key="" data-hash="/27.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Redis是如何执行的</h2>
        </div>
    </a>
</article>
            
                
<article class="has-image">
    <a href="/posts/redis%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
        
        
            <div class="article-image">
                
                    <img src="/25.jpg" loading="lazy" data-key="" data-hash="/25.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Redis问题汇总和相关解决方案</h2>
        </div>
    </a>
</article>
            
        </div>
    </div>
</aside>

     
    
        
    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis/qq","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/alus"],"lang":"zh-CN","locale":{"admin":"Admin"},"requiredMeta":["name","email","url"],"serverURL":"https://blog-api-2w7xkqg6y-ahaomin.vercel.app/","visitor":true});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 ahao&#39;s Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.10.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>
        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#持久化触发">持久化触发</a>
      <ol>
        <li><a href="#手动触发">手动触发</a>
          <ol>
            <li><a href="#save-命令">save 命令</a></li>
            <li><a href="#bgsave-命令">bgsave 命令</a></li>
          </ol>
        </li>
        <li><a href="#自动触发">自动触发</a>
          <ol>
            <li><a href="#save-m-n">save m n</a></li>
            <li><a href="#flushall">flushall</a></li>
          </ol>
        </li>
        <li><a href="#主从同步触发">主从同步触发</a></li>
      </ol>
    </li>
    <li><a href="#配置说明">配置说明</a></li>
    <li><a href="#配置查询">配置查询</a></li>
    <li><a href="#配置设置">配置设置</a></li>
    <li><a href="#rdb-文件恢复">RDB 文件恢复</a></li>
    <li><a href="#rdb-优缺点">RDB 优缺点</a>
      <ol>
        <li><a href="#rdb-优点">RDB 优点</a></li>
        <li><a href="#rdb-缺点">RDB 缺点</a></li>
      </ol>
    </li>
    <li><a href="#禁用持久化">禁用持久化</a></li>
    <li><a href="#小结">小结</a></li>
  </ol>

  <ol>
    <li><a href="#简介">简介</a></li>
    <li><a href="#持久化查询和设置">持久化查询和设置</a>
      <ol>
        <li><a href="#查询-aof-启动状态">查询 AOF 启动状态</a></li>
        <li><a href="#开启-aof-持久化">开启 AOF 持久化</a>
          <ol>
            <li><a href="#命令行启动-aof">命令行启动 AOF</a></li>
            <li><a href="#配置文件启动-aof">配置文件启动 AOF</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#触发持久化">触发持久化</a>
      <ol>
        <li><a href="#自动触发-1">自动触发</a></li>
        <li><a href="#手动触发-1">手动触发</a></li>
      </ol>
    </li>
    <li><a href="#aof-文件重写">AOF 文件重写</a>
      <ol>
        <li><a href="#什么是-aof-重写">什么是 AOF 重写？</a></li>
        <li><a href="#aof-重写实现">AOF 重写实现</a></li>
        <li><a href="#aof-重写流程">AOF 重写流程</a></li>
      </ol>
    </li>
    <li><a href="#配置说明-1">配置说明</a></li>
    <li><a href="#数据恢复">数据恢复</a>
      <ol>
        <li><a href="#正常数据恢复">正常数据恢复</a></li>
        <li><a href="#简单异常数据恢复">简单异常数据恢复</a></li>
        <li><a href="#复杂异常数据恢复">复杂异常数据恢复</a></li>
      </ol>
    </li>
    <li><a href="#优缺点">优缺点</a>
      <ol>
        <li><a href="#aof-优点">AOF 优点</a></li>
        <li><a href="#aof-缺点">AOF 缺点</a></li>
      </ol>
    </li>
    <li><a href="#小结-1">小结</a></li>
  </ol>

  <ol>
    <li><a href="#开启混合持久化">开启混合持久化</a>
      <ol>
        <li><a href="#通过命令行开启">通过命令行开启</a></li>
        <li><a href="#通过修改-redis-配置文件开启">通过修改 Redis 配置文件开启</a></li>
      </ol>
    </li>
    <li><a href="#实例运行">实例运行</a></li>
    <li><a href="#数据恢复和源码解析">数据恢复和源码解析</a>
      <ol>
        <li><a href="#混合持久化的加载流程">混合持久化的加载流程</a></li>
        <li><a href="#源码解析">源码解析</a></li>
      </ol>
    </li>
    <li><a href="#优缺点-1">优缺点</a></li>
    <li><a href="#持久化最佳实践">持久化最佳实践</a>
      <ol>
        <li><a href="#控制持久化开关">控制持久化开关</a></li>
        <li><a href="#主从部署">主从部署</a></li>
        <li><a href="#使用混合持久化">使用混合持久化</a></li>
        <li><a href="#使用配置更高的机器">使用配置更高的机器</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
